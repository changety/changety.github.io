<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Bian's blog]]></title>
  <link href="http://changety.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://changety.github.io/"/>
  <updated>2017-06-23T14:53:37+08:00</updated>
  <id>http://changety.github.io/</id>
  <author>
    <name><![CDATA[BianYuting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fresco图片解码部分源码分析及webp vs jpeg指标对比]]></title>
    <link href="http://changety.github.io/blog/2017/06/20/fresco-jpg-webp-decode/"/>
    <updated>2017-06-20T16:04:07+08:00</updated>
    <id>http://changety.github.io/blog/2017/06/20/fresco-jpg-webp-decode</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<h2><em>之前的文章写过<a href="http://changety.github.io/blog/2016/01/31/webp-research/">webp图片的调研</a>，这篇分析一下fresco的decoder部分的源码，同时从响应、下载、解码、大小四个指标上对比同一张图片的webp 与jpg格式。这里响应时间应该与图片格式本身没有关系，但这里为了对服务器接口做一个测试也加入了对比；下载时间应该与图片size成正相关，这里也加入对比，看看结果是否符合预期。根据google官网介绍，目前WebP与JPG相比较，编解码速度上，毫秒级别上：编码速度webp比jpg慢10倍，解码速度慢1.5倍。在我们的使用场景下，编码速度的影响可以被忽略，因为服务器会在用户第一次请求时，编码生成jpg图片对应的webp图片，之后都会被缓存下来，可以认为几乎所有用户的请求都能命中缓存。解码方面，则是每个用户拿到webp图片都必经的开销，因此解码速度是本次测试对比的关键指标。</em></h2>

<h1>Fresco WebP支持</h1>

<p>我们的客户端使用的是<a href="https://github.com/facebook/fresco">fresco</a>图片库，根据其<a href="http://frescolib.org/docs/webp-support.html#main_wrap">官方文档说明</a>：</p>

<blockquote><p>Android added webp support in version 4.0 and improved it in 4.2.1:
4.0+ (Ice Cream Sandwich): basic webp support
4.2.1+ (Jelly Beam MR1): support for transparency and losless wepb
Fresco handles webp images by default if the OS supports it. So you can use webp with 4.0+ and trasparency and losless webps from 4.2.1.
Fresco also supports webp for older OS versions. The only thing you need to do is add thewebpsupportlibrary to your dependencies. So if you want to use webps on Gingerbread just add the following line to your gradle build file:
<em>compile &lsquo;com.facebook.fresco:webpsupport:1.3.0&rsquo;</em></p></blockquote>

<p>因此我们需要引入webpsupprot库，这样子fresco会处理对webp的支持。下面也会从源码上分析，fresco是如何解码webp的。</p>

<h1>Fresco Producer源码分析</h1>

<h2>Producer继承结构</h2>

<p>首先我们看一下Frecso中Producer的继承结构图：</p>

<div align=center>
<img src="http://upload-images.jianshu.io/upload_images/76332-66b1c9b26eb0033d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="600" height="600" alt="fresco producer继承关系"/>
</div>


<h2>Producer流水线</h2>

<p><code>ProducerSequenceFactory</code>是专门将生成各类链接起来的Producer，根据其中的逻辑，这里将可能涉及层次最深的Uri——网络Uri的Producer链在此列出，它会到每个缓存中查找数据，最后如果都没有命中，则会去网络上下载。</p>

<table>
<thead>
<tr>
<th style="text-align:center;">顺序</th>
<th style="text-align:center;">Producer</th>
<th style="text-align:center;">是否必须</th>
<th style="text-align:left;">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">1</td>
<td style="text-align:center;">PostprocessedBitmapMemoryCacheProducer</td>
<td style="text-align:center;">否</td>
<td style="text-align:left;">在Bitmap缓存中查找被PostProcess过的数据</td>
</tr>
<tr>
<td style="text-align:center;">2</td>
<td style="text-align:center;">PostprocessorProducer</td>
<td style="text-align:center;">否</td>
<td style="text-align:left;">对下层Producer传上来的数据进行PostProcess</td>
</tr>
<tr>
<td style="text-align:center;">3</td>
<td style="text-align:center;">BitmapMemoryCacheGetProducer</td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">使Producer序列只读</td>
</tr>
<tr>
<td style="text-align:center;">4</td>
<td style="text-align:center;">ThreadHandoffProducer</td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">使下层Producer工作在后台进程中执行</td>
</tr>
<tr>
<td style="text-align:center;">5</td>
<td style="text-align:center;">BitmapMemoryCacheKeyMultiplexProducer</td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">使多个相同已解码内存缓存键的ImageRequest都从相同Producer中获取数据</td>
</tr>
<tr>
<td style="text-align:center;">6</td>
<td style="text-align:center;">BitmapMemoryCacheProducer</td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">从已解码的内存缓存中获取数据</td>
</tr>
<tr>
<td style="text-align:center;">7</td>
<td style="text-align:center;"><strong>DecodeProducer</strong></td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">将下层Producer产生的数据解码</td>
</tr>
<tr>
<td style="text-align:center;">8</td>
<td style="text-align:center;">ResizeAndRotateProducer</td>
<td style="text-align:center;">否</td>
<td style="text-align:left;">将下层Producer产生的数据变换</td>
</tr>
<tr>
<td style="text-align:center;">9</td>
<td style="text-align:center;">EncodedCacheKeyMultiplexProducer</td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">使多个相同未解码内存缓存键的ImageRequest都从相同Producer中获取数据</td>
</tr>
<tr>
<td style="text-align:center;">10</td>
<td style="text-align:center;">EncodedMemoryCacheProducer</td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">从未解码的内存缓存中获取数据</td>
</tr>
<tr>
<td style="text-align:center;">11</td>
<td style="text-align:center;">DiskCacheProducer</td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">从文件缓存中获取数据</td>
</tr>
<tr>
<td style="text-align:center;">12</td>
<td style="text-align:center;">WebpTranscodeProducer</td>
<td style="text-align:center;">否</td>
<td style="text-align:left;">Transcodes WebP to JPEG / PNG</td>
</tr>
<tr>
<td style="text-align:center;">13</td>
<td style="text-align:center;"><strong>NetworkFetchProducer</strong></td>
<td style="text-align:center;">是</td>
<td style="text-align:left;">从网络上获取数据</td>
</tr>
</tbody>
</table>


<hr />

<p>为了获得每一张网络图片的大小、响应时间、下载时间、decode时间，我们需要探索Fresco的源码，挂上钩子去得到这些指标；这里我们关心<code>DecoderProducer</code>、<code>NetworkFetchProducer</code>，顾名思义，这两个Producer分别用于解码和网络加载相关。</p>

<h3>DecodeProducer解码过程</h3>

<p>DecodeProducer负责将未解码的数据生产出解码的数据。先看produceResults方法。</p>

<pre><code class="java">  @Override
  public void produceResults(final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer, final ProducerContext producerContext) {
    final ImageRequest imageRequest = producerContext.getImageRequest();
    ProgressiveDecoder progressiveDecoder;
    if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {
      progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext, mDecodeCancellationEnabled);
    } else {
      ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);
      progressiveDecoder = new NetworkImagesProgressiveDecoder(consumer, producerContext, jpegParser, mProgressiveJpegConfig, mDecodeCancellationEnabled);
    }
    mInputProducer.produceResults(progressiveDecoder, producerContext);
  }
</code></pre>

<p>通过判断uri的类型 选择不同的渐近式解释器，local和network都继承自ProgressiveDecoder</p>

<p>在<code>ProgressiveDecoder</code>的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是<code>ImageDecode</code>r#decodeImage方法，这个方法将encodedImage解析成<code>CloseableImage</code>：</p>

<pre><code class="java">    /** Performs the decode synchronously. */
    private void doDecode(EncodedImage encodedImage, @Status int status) {
      if (isFinished() || !EncodedImage.isValid(encodedImage)) {
        return;
      }
      final String imageFormatStr;
      ImageFormat imageFormat = encodedImage.getImageFormat();
      if (imageFormat != null) {
        imageFormatStr = imageFormat.getName();
      } else {
        imageFormatStr = "unknown";
      }
      final String encodedImageSize;
      final String sampleSize;
      final boolean isLast = isLast(status);
      final boolean isLastAndComplete = isLast &amp;&amp; !statusHasFlag(status, IS_PARTIAL_RESULT);
      final boolean isPlaceholder = statusHasFlag(status, IS_PLACEHOLDER);
      if (encodedImage != null) {
        encodedImageSize = encodedImage.getWidth() + "x" + encodedImage.getHeight();
        sampleSize = String.valueOf(encodedImage.getSampleSize());
      } else {
        // We should never be here
        encodedImageSize = "unknown";
        sampleSize = "unknown";
      }
      final String requestedSizeStr;
      final ResizeOptions resizeOptions = mProducerContext.getImageRequest().getResizeOptions();
      if (resizeOptions != null) {
        requestedSizeStr = resizeOptions.width + "x" + resizeOptions.height;
      } else {
        requestedSizeStr = "unknown";
      }
      try {
        long queueTime = mJobScheduler.getQueuedTime();
        long decodeDuration = -1;
        String imageUrl = encodedImage.getEncodedCacheKey().getUriString();
        int length = isLastAndComplete || isPlaceholder ? encodedImage.getSize() : getIntermediateImageEndOffset(encodedImage);
        QualityInfo quality = isLastAndComplete || isPlaceholder ? ImmutableQualityInfo.FULL_QUALITY : getQualityInfo();

        mProducerListener.onProducerStart(mProducerContext.getId(), PRODUCER_NAME);
        CloseableImage image = null;
        try {
          long nowTime = System.currentTimeMillis();
          image = mImageDecoder.decode(encodedImage, length, quality, mImageDecodeOptions);
          decodeDuration = System.currentTimeMillis() - nowTime;
        } catch (Exception e) {
          Map&lt;String, String&gt; extraMap = getExtraMap(image, imageUrl, queueTime, decodeDuration, quality, isLast, imageFormatStr, encodedImageSize, requestedSizeStr, sampleSize);
          mProducerListener.onProducerFinishWithFailure(mProducerContext.getId(), PRODUCER_NAME, e, extraMap);
          handleError(e);
          return;
        }
        Map&lt;String, String&gt; extraMap = getExtraMap(image, imageUrl, queueTime, decodeDuration, quality, isLast, imageFormatStr, encodedImageSize, requestedSizeStr, sampleSize);
        mProducerListener.onProducerFinishWithSuccess(mProducerContext.getId(), PRODUCER_NAME, extraMap);
        handleResult(image, status);
      } finally {
        EncodedImage.closeSafely(encodedImage);
      }
    }
</code></pre>

<p>因此我们在#doDecoder方法在decode前后插入解码时长计算:</p>

<pre><code class="java">  long nowTime = System.currentTimeMillis();
  image = mImageDecoder.decode(encodedImage, length, quality, mImageDecodeOptions);
  decodeDuration = System.currentTimeMillis() - nowTime;
</code></pre>

<h4>ImageDecoder</h4>

<p><code>DecoderProducer</code> 中是依赖<code>ImageDecoder</code>类，用来将未解码的<code>EncodeImage</code>解码成对应的<code>CloseableImage</code>。<code>ImageDecoder</code>中先判断未解码的图片类型：
<code>  
  private final ImageDecoder mDefaultDecoder = new ImageDecoder() {
    @Override
    public CloseableImage decode(EncodedImage encodedImage, int length, QualityInfo qualityInfo, ImageDecodeOptions options) {
      ImageFormat imageFormat = encodedImage.getImageFormat();
      if (imageFormat == DefaultImageFormats.JPEG) {
        return decodeJpeg(encodedImage, length, qualityInfo, options);
      } else if (imageFormat == DefaultImageFormats.GIF) {
        return decodeGif(encodedImage, length, qualityInfo, options);
      } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {
        return decodeAnimatedWebp(encodedImage, length, qualityInfo, options);
      } else if (imageFormat == ImageFormat.UNKNOWN) {
        throw new IllegalArgumentException("unknown image format");
      }
      return decodeStaticImage(encodedImage, options);
    }
  };
</code></p>

<h4>ImageFormatChecker</h4>

<p>这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。根据代码能看出，这里分为几种。</p>

<pre><code class="java">  public static final ImageFormat JPEG = new ImageFormat("JPEG", "jpeg");
  public static final ImageFormat PNG = new ImageFormat("PNG", "png");
  public static final ImageFormat GIF = new ImageFormat("GIF", "gif");
  public static final ImageFormat BMP = new ImageFormat("BMP", "bmp");
  public static final ImageFormat WEBP_SIMPLE = new ImageFormat("WEBP_SIMPLE", "webp");
  public static final ImageFormat WEBP_LOSSLESS = new ImageFormat("WEBP_LOSSLESS", "webp");
  public static final ImageFormat WEBP_EXTENDED = new ImageFormat("WEBP_EXTENDED", "webp");
  public static final ImageFormat WEBP_EXTENDED_WITH_ALPHA = new ImageFormat("WEBP_EXTENDED_WITH_ALPHA", "webp");
  public static final ImageFormat WEBP_ANIMATED = new ImageFormat("WEBP_ANIMATED", "webp");
</code></pre>

<p>本篇我们关心以下几种：
- JPEG
- WEBP_SIMPLE
- GIF
- WEBP_ANIMATED</p>

<p>从是否静态图上来看，为两种：
- 可动 ，用AnimatedImageFactory进行解析
- 不可动，用PlatformDecoder进行解析</p>

<h4>AnimatedImageFactory</h4>

<p>AnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。
在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。</p>

<pre><code>  private static AnimatedImageDecoder loadIfPresent(final String className) {
    try {
      Class&lt;?&gt; clazz = Class.forName(className);
      return (AnimatedImageDecoder) clazz.newInstance();
    } catch (Throwable e) {
      return null;
    }
  }

  static {
    sGifAnimatedImageDecoder = loadIfPresent("com.facebook.animated.gif.GifImage");
    sWebpAnimatedImageDecoder = loadIfPresent("com.facebook.animated.webp.WebPImage");
  }
</code></pre>

<p>AnimatedImageDecoder又分别有两个实现：
- <code>WebpImage</code>
- <code>GifImage</code></p>

<p><img src="http://upload-images.jianshu.io/upload_images/76332-9ce98211c5be0f50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WebpImage与GifImage" /></p>

<p>解析分为两个步骤：
1. 通过<code>AnimatedImageDecode</code>r解析出AnimatedImage
2. 利用getCloseableImage从<code>AnimatedImage</code>中构造出<code>CloseableAnimatedImage</code>。这是<code>CloseableImage</code>的之类。
getCloseableImage的逻辑如下：
1. 用decodeAllFrames解析出所有帧
2. 用createPreviewBitmap构造预览的bitmap
3. 构造<code>AnimatedImageResult</code>对象
4. 用<code>AnimatedImageResult</code>构造<code>CloseableAnimatedImage</code>对象。</p>

<h4>PlatformDecoder</h4>

<p><code>PlatformDecoder</code>是一个接口，代表不同平台。我们看他的实现类有哪些:</p>

<p><img src="http://upload-images.jianshu.io/upload_images/76332-37a7a0bdcb84bc8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PlatformDecoder具体实现" /></p>

<pre><code class="java">public interface PlatformDecoder {
  /**
   * Creates a bitmap from encoded bytes. Supports JPEG but callers should use {@link
   * #decodeJPEGFromEncodedImage} for partial JPEGs.
   *
   * @param encodedImage the reference to the encoded image with the reference to the encoded bytes
   * @param bitmapConfig the {@link android.graphics.Bitmap.Config} used to create the decoded
   * Bitmap
   * @return the bitmap
   * @throws TooManyBitmapsException if the pool is full
   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
   */
  CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage(final EncodedImage encodedImage, Bitmap.Config bitmapConfig);

  /**
   * Creates a bitmap from encoded JPEG bytes. Supports a partial JPEG image.
   *
   * @param encodedImage the reference to the encoded image with the reference to the encoded bytes
   * @param bitmapConfig the {@link android.graphics.Bitmap.Config} used to create the decoded
   * Bitmap
   * @param length the number of encoded bytes in the buffer
   * @return the bitmap
   * @throws TooManyBitmapsException if the pool is full
   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
   */
  CloseableReference&lt;Bitmap&gt; decodeJPEGFromEncodedImage(EncodedImage encodedImage, Bitmap.Config bitmapConfig, int length);
}


getBitmapFactoryOptions 获取BitmapFactory.Options
decodeByteArrayAsPurgeable 获取bitmap
pinBitmap 真正的decode
</code></pre>

<h1>NetworkFetchProducer</h1>

<p><code>NetworkFetchProducer</code>负责从网络层获取图片流，持有<code>NetworkFetcher</code>的实现类；测试代码中，我们添加了OkHttp3的<code>OkHttpNetworkFetcher</code>作为fetcher；我们关心<code>NetworkFetchProducer</code>中的这个方法：</p>

<pre><code class="java">  private void handleFinalResult(PooledByteBufferOutputStream pooledOutputStream, FetchState fetchState) {
    Map&lt;String, String&gt; extraMap = getExtraMap(fetchState, pooledOutputStream.size());
    ProducerListener listener = fetchState.getListener();
    listener.onProducerFinishWithSuccess(fetchState.getId(), PRODUCER_NAME, extraMap);
    listener.onUltimateProducerReached(fetchState.getId(), PRODUCER_NAME, true);
    notifyConsumer(pooledOutputStream, Consumer.IS_LAST | fetchState.getOnNewResultStatusFlags(), fetchState.getResponseBytesRange(), fetchState.getConsumer());
  }
</code></pre>

<p>该方法中<code>FetchState</code>记录了一张图片从服务端响应到IO读取的耗时记录。同样的，也是通过<code>ProducerListener</code>的#onProducerFinishWithSuccess方法回调出去。</p>

<h1>计算decode &amp; fecth的时间</h1>

<p>每个<code>Producer</code>的接口实现，都会持有<code>ProducerContext</code>，其中的<code>ProducerListener</code>会回调<code>Producer</code>各个阶段的事件。我们关心这个方法：</p>

<blockquote><p>/<em>*
* Called when a producer successfully finishes processing current unit of work.
* @param extraMap Additional parameters about the producer. This map is immutable and will
* throw an exception if attempts are made to modify it.
</em>/
void onProducerFinishWithSuccess(String requestId, String producerName, @Nullable Map&lt;String, >String> extraMap);</p></blockquote>

<p>该方法会在<code>Producer</code>结束时回调出来，我们利用Fresco包里的<code>RequestLoggingListener</code>，便可监听到<code>DecoderProducer</code>和<code>NetworkFetchProducer</code>的回调。</p>

<pre><code class="java">    @Override
    public void onCreate() {
        super.onCreate();
        FLog.setMinimumLoggingLevel(FLog.VERBOSE);
        Set&lt;RequestListener&gt; listeners = new HashSet&lt;&gt;(1);
        listeners.add(new RequestLoggingListener());
        ImagePipelineConfig config = ImagePipelineConfig.newBuilder(this)
            .setRequestListeners(listeners)
            .setNetworkFetcher(new OkHttpNetworkFetcher(OKHttpFactory.getInstance().getOkHttpClient()))
            .build();
        DraweeConfig draweeConfig = DraweeConfig.newBuilder().setDrawDebugOverlay(DebugOverlayHelper.isDebugOverlayEnabled(this)).build();
        Fresco.initialize(this, config, draweeConfig);
        Fresco.getImagePipeline().clearDiskCaches();
    }
</code></pre>

<p>我们通过在Fresco初始化Builder中加入<code>RequestLoggingListener</code>，并改造<code>RequestLoggingListener</code>的onProducerFinishWithSuccess方法:</p>

<pre><code class="java">  @Override
  public synchronized void onProducerFinishWithSuccess(String requestId, String producerName, @Nullable Map&lt;String, String&gt; extraMap) {
    if (FLog.isLoggable(FLog.VERBOSE)) {
      Pair&lt;String, String&gt; mapKey = Pair.create(requestId, producerName);
      Long startTime = mProducerStartTimeMap.remove(mapKey);
      long currentTime = getTime();
      long producerDuration = -1;
      FLog.v(TAG, "time %d: onProducerFinishWithSuccess: " + "{requestId: %s, producer: %s, elapsedTime: %d ms, extraMap: %s}", currentTime, requestId, producerName, producerDuration = getElapsedTime(startTime, currentTime), extraMap);
      if (sOnProducer != null) {
        sOnProducer.onProducer(producerDuration, extraMap, producerName);
      }
    }
  }
</code></pre>

<p>通过将Producer的信息回调给外面，至此我们就拿到了每一个Producer的回调信息，通过producerName的过滤就可以拿到关心的信息，这里我们关心<code>DecoderProducer</code>和<code>NetworkFetchProducer</code>的信息。</p>

<h3>decode时间计算</h3>

<p>在<code>DecoderProducer</code>的doDecode方法中插入:</p>

<pre><code class="java"> long nowTime = System.currentTimeMillis();
 image = mImageDecoder.decode(encodedImage, length, quality, mImageDecodeOptions);
 decodeDuration = System.currentTimeMillis() - nowTime;
</code></pre>

<p>decodeDuration放入onProducerFinishWithSuccess的extraMap当中</p>

<h3>network fecther时间计算</h3>

<p><code>OkHttpNetworkFetcher</code>中定义着几个常量值：</p>

<pre><code class="java">  public static final String QUEUE_TIME = "resp_time"; //修改为响应时间
  public static final String FETCH_TIME = "fetch_time";
  public static final String TOTAL_TIME = "total_time";
  public static final String IMAGE_SIZE = "image_size";
  public static final String IMAGE_URL = "image_url"; //新增
</code></pre>

<ul>
<li><code>QUEUE_TIME</code>为请求丢入请求线程池到最后请求成功响应的时间</li>
<li><code>FETCH_TIME</code>为从response读完IO流的时间</li>
<li><code>IMAGE_SIZE</code>为response header中的content-length，即图片大小</li>
</ul>


<p>这些数据都最终会被丢入extraMap，回调给外面。</p>

<h1>数据对比</h1>

<h2>jpg&amp;webp指标对比:</h2>

<div align=center>
<img src="http://upload-images.jianshu.io/upload_images/76332-f960ec0cb0bed228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="400" height="400" alt="jpg webp指标对比"/>
</div>


<table>
<thead>
<tr>
<th style="text-align:center;">格式</th>
<th style="text-align:center;">图片数</th>
<th style="text-align:center;">大小</th>
<th style="text-align:left;">响应时间</th>
<th style="text-align:center;">下载时间</th>
<th style="text-align:center;">解码时间</th>
<th style="text-align:center;">总用时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">jpg</td>
<td style="text-align:center;">100</td>
<td style="text-align:center;">33497748B / 31.9MB</td>
<td style="text-align:left;">3384ms</td>
<td style="text-align:center;">5582ms</td>
<td style="text-align:center;">7225ms</td>
<td style="text-align:center;">16191ms</td>
</tr>
<tr>
<td style="text-align:center;">webp</td>
<td style="text-align:center;">100</td>
<td style="text-align:center;">11127628B / 10.6MB </td>
<td style="text-align:left;">3388ms</td>
<td style="text-align:center;">2552ms</td>
<td style="text-align:center;">9806ms</td>
<td style="text-align:center;">15746ms</td>
</tr>
</tbody>
</table>


<p>以上数据经过几轮测试，都接近这个数据对比。 图片源来自项目线上的图片，图片接口来自公司CND接口，使用相同quality参数，带同一张图片的不同格式参数。解码总时间大概是JPG:WEBP = 1 : 1.3左右，接近官方的1.5倍性能差距。总大小上，webp几乎只有jpg的1/3，远超超官方的30%，这个估计是大多数jpg没有经过压缩就直接上传了。下载时间基本上与size成正比。</p>

<p><a href="http://p1.music.126.net/6OARlbfxOysQJU5iZ8WKSA==/18769762999688243.jpg?imageView=1&amp;type=webp&amp;quality=100">http://p1.music.126.net/6OARlbfxOysQJU5iZ8WKSA==/18769762999688243.jpg?imageView=1&amp;type=webp&amp;quality=100</a></p>

<p><a href="http://p1.music.126.net/6OARlbfxOysQJU5iZ8WKSA==/18769762999688243.jpg?imageView=1&amp;quality=100">http://p1.music.126.net/6OARlbfxOysQJU5iZ8WKSA==/18769762999688243.jpg?imageView=1&amp;quality=100</a></p>

<h2>gif&amp;anim-webp指标对比:</h2>

<div align=center>
<img src="http://upload-images.jianshu.io/upload_images/76332-114e6bf70693178d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="400" height="400" alt="gif&anim-webp指标对比"/>
</div>


<table>
<thead>
<tr>
<th style="text-align:center;">格式</th>
<th style="text-align:center;">图片数</th>
<th style="text-align:center;">大小</th>
<th style="text-align:left;">响应时间</th>
<th style="text-align:center;">下载时间</th>
<th style="text-align:center;">解码时间</th>
<th style="text-align:center;">总用时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">gif</td>
<td style="text-align:center;">85</td>
<td style="text-align:center;">66343142B / 63.26MB</td>
<td style="text-align:left;">2597ms</td>
<td style="text-align:center;">6052ms</td>
<td style="text-align:center;">272ms</td>
<td style="text-align:center;">8921ms</td>
</tr>
<tr>
<td style="text-align:center;">anim-webp</td>
<td style="text-align:center;">85</td>
<td style="text-align:center;">20342068B / 19.39MB</td>
<td style="text-align:left;">2687ms</td>
<td style="text-align:center;">3809ms</td>
<td style="text-align:center;">240ms</td>
<td style="text-align:center;">6736ms</td>
</tr>
</tbody>
</table>


<p>同样地, 分别取了同一张GIF图片的，原始版本与WEBP版本来对比。</p>

<p><a href="http://p1.music.126.net/rhGo28bJP19-T0xmtpg6jw==/19244752021149272.jpg">http://p1.music.126.net/rhGo28bJP19-T0xmtpg6jw==/19244752021149272.jpg</a>
<a href="http://p1.music.126.net/rhGo28bJP19-T0xmtpg6jw==/19244752021149272.jpg?imageView=1&amp;type=webp&amp;tostatic=0">http://p1.music.126.net/rhGo28bJP19-T0xmtpg6jw==/19244752021149272.jpg?imageView=1&amp;type=webp&amp;tostatic=0</a></p>

<h2>size压缩对比也接近1：3；另外这里的解码时间是不准确的，因为webp与gif在fresco中都是<code>AnimatedImage</code>，他们的decode调的是nativeCreateFromNativeMemory方法，这个方法返回是对应的<code>WebPImage</code> 与<code>GifImage</code>对象，表中的解码时间也是构建这个对象的耗时；动图渲染时，主要调用的是<code>AnimatedDrawableBackendImpl</code>中renderFrame方法。但我们可以粗略认为，每一帧的渲染耗时对比，接近jpg与webp的耗时；因为gif与anim-webp分别是由一帧一帧的jpg与webp组成。</h2>

<h1>总结</h1>

<h2>webp与jpg相比，包括anim-webp与gif， 在相同的图片质量，图片大小上，webp有着巨大的优势，解码速度毫秒级的差距也完全在接收范围内， 而图片大小最终转化为带宽、存储空间、加载速度上的优势。因此在有条件的情况，app中完全可以用webp来替代jpg格式以提升加载速度、降低存储空间、节省带宽费用。另外在android上，使用fresco作为图片库，可以几乎无成本的接入webp。</h2>

<h1>参考</h1>

<p>webp图片介绍 <a href="http://changety.github.io/blog/2016/01/31/webp-research/">http://changety.github.io/blog/2016/01/31/webp-research/</a></p>

<p>webp常见问题 <a href="https://developers.google.com/speed/webp/faq">https://developers.google.com/speed/webp/faq</a></p>

<p>fresco decode过程 <a href="https://guolei1130.github.io/2016/12/13/fresco%E5%9B%BE%E7%89%87decode%E7%9A%84%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B/">https://guolei1130.github.io/2016/12/13/fresco%E5%9B%BE%E7%89%87decode%E7%9A%84%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[webp调研]]></title>
    <link href="http://changety.github.io/blog/2016/01/31/webp-research/"/>
    <updated>2016-01-31T16:04:07+08:00</updated>
    <id>http://changety.github.io/blog/2016/01/31/webp-research</id>
    <content type="html"><![CDATA[<h1>WebP简介：</h1>

<p>&emsp;&emsp;WebP 格式是 Google 于2010年发布的一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。它具有较优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性。目前googleG+、YouTube以及Google Play全站都在使用WebP格式的图片。<a href="https://github.com/amfe/article/issues/21">15年双11手淘前端技术巡演中提到</a>，淘宝3年前native层面就已经支持WebP， 两年前H5页面全面支持。QQ空间装扮、淘宝广告图，<a href="https://code.facebook.com/posts/485459238254631/improving-facebook-on-android/">Facebook Android</a>也都使用WebP。</p>

<p>以下通过研究WebP图片格式，尽可能全面地了解WebP图片的优劣势以及应用WebP图片给我们带来的收益以及风险，最终达到提升用户体验，提升图片加载速度，节省带宽的目的。</p>

<hr />

<h1>WebP优势</h1>

<h2>官方测试：</h2>

<p><a href="https://developers.google.com/speed/webp/docs/webp_lossless_alpha_study">根据测试</a>，WebP无损压缩的图片比PNG格式图片，文件大小上少 26%；</p>

<p><a href="https://developers.google.com/speed/webp/docs/webp_study">根据测试</a>，WebP有损图片在同样<a href="https://en.wikipedia.org/wiki/Structural_similarity">SSIM</a>质量指标上比JPEG格式图片少25~34%。 SSIM是一种衡量两张数字影像相似的指标</p>

<h3>有损压缩测试方法简述：</h3>

<p>1.将PNG图片设置不同的压缩参数压缩成JPEG图片，记录压缩后的对比的SSIM。</p>

<p>2.将同一张PNG图片压缩成WebP图片，压缩的WebP图片的SSIM指标必须比1中记录的SSIM高。</p>

<h4>jpg、webp相同ssim测试</h4>

<p><img src="/images/webp_image/webp-1.jpg"></p>

<h2>其他测试：</h2>

<p>同样质量的WebP与JPG图片，<a href="http://labs.qiang.it/wen/webp/test.html">在线加载速度测试</a>。测试的JPG和WebP图片大小如下：</p>

<h4>在线测试图片大小</h4>

<p><img src="/images/webp_image/webp-2.jpg"></p>

<h4>测试数据折线图如下：</h4>

<p><img src="/images/webp_image/webp-3.jpg"></p>

<p>从折线图可以看到，WebP虽然会增加额外的解码时间，但由于减少了文件体积，缩短了加载的时间，页面的渲染速度加快了。同时，随着图片数量的增多，WebP页面加载的速度相对JPG页面增快了。所以，使用WebP基本没有技术阻碍，还能带来性能提升以及带宽节省。</p>

<p>通过以上两组对比可以得知，WebP在文件大小以及传输速度上肯定是拥有优势的，将极大节省用户及cdn流量。</p>

<h1>动图</h1>

<p>GIF 图片主要应用于图片分享类应用中，如微博等。与传统的 GIF 图比较，动态 WebP 的优势在于：
1.支持有损和无损压缩，并且可以合并有损和无损图片帧；</p>

<p>2.体积更小，GIF 转成有损动态 WebP 后可以减小 64% 的体积，转成无损可以节省 19% 的体积；</p>

<p>3.颜色更丰富，支持 24-bit 的 RGB 颜色以及 8-bit 的 Alpha 透明通道（而GIF 只支持8-bit RGB 颜色以及 1-bit 的透明）；</p>

<p>4.添加了关键帧、metadata 等数据；</p>

<h2>动图测试：</h2>

<p><a href="http://7xscia.com1.z0.glb.clouddn.com/test_001.gif">GIF动图</a>1 63.9KB   <a href="http://7xscia.com1.z0.glb.clouddn.com/test_001.gif?imageMogr2/format/webp">WebP动图1</a> 28.9KB</p>

<p><a href="http://7xscia.com1.z0.glb.clouddn.com/test_002.gif">GIF动图2</a> 1.7MB   <a href="http://7xscia.com1.z0.glb.clouddn.com/test_002.gif?imageMogr2/format/webp">WebP动图2</a> 479KB</p>

<p><a href="http://7xscia.com1.z0.glb.clouddn.com/test_003.gif">GIF动图3</a> 2MB <a href="http://7xscia.com1.z0.glb.clouddn.com/test_003.gif?imageMogr2/format/webp">WebP动图3</a> 208KB</p>

<h1>WebP劣势：</h1>

<p>1.各个端支持情况不一。这点会在下一节中详细说明。</p>

<p>2.迁移成本较大，需要对所有图片重新编码，考虑到对旧版的支持，需要额外开辟空间存两种格式的图片。</p>

<p>3.编解码速度上，根据Google的测试，目前WebP与JPG相比较，毫秒级别上，编码速度慢10倍，解码速度慢1.5倍。编码速度即可被没影响，我们只是在上传时生成一份WebP图片。解码速度则需要客户端综合节省下的流量来综合考虑。总之带宽节省比cpu消耗更有价值</p>

<p>4.尽管有不少app在使用WebP图片，但与JPG/PNG相比还是太少了，接受度并没有太高。</p>

<p>5.app中部分“归档化”的交互操作，比如图片保存，因此这些交互操作上需要进行WebP编解码成JPG。直接保存下来的webp图片，非常不方便reuse以及review。</p>

<h1>WebP各端支持情况：</h1>

<h4>浏览器支持情况：</h4>

<p><img src="/images/webp_image/webp-4.jpg"></p>

<p>根据对目前国内浏览器占比与 WebP 的兼容性分析，大约有 50% 以上的国内用户可以直接体验到 WebP。</p>

<h2>如何检测浏览器是否支持：</h2>

<p>1.JavaScript 能力检测，对支持 WebP 的用户输出 WebP 图片</p>

<p>2.使用 WebP 支持插件：WebPJS</p>

<p>3.有一部分CDN厂商是提供webp检测服务</p>

<p>4.Http header accept type 返回接受的image typ</p>

<p>5.GooglePageSpeed提供自动将jpg转化成webp，提供给支持webp的浏览器上。</p>

<h2>Android：</h2>

<p>Android 4.0及以上原生支持； 4.0以下可以使用官方提供提供的<a href="https://github.com/alexey-pelykh/webp-android-backport">编解码库</a>。</p>

<h2>iOS：</h2>

<p>iOS native 不支持，safari目前也不支持。据说ios 10的safari有可能会支持。native支持层面，<a href="https://github.com/carsonmcdonald/WebP-iOS-example">google官方</a>，以及<a href="https://github.com/seanooi/iOS-WebP">第三方</a>都提供了解决方案。国内也有不少ios团队在做webp图片的支持工作。</p>

<h2>视觉设计：</h2>

<p>Photoshop 原生是不支持WebP的，但有插件提供WebP支持。</p>

<h4>webp各端支持情况</h4>

<p><img src="/images/webp_image/webp-5.jpg"></p>

<h1>总结：</h1>

<p>1.图片占据cdn服务中很大的一部分流量，更节省的图片流量对产品及用户肯定有巨大提升。一部分cnd厂商是支持webp转化服务或者web支持探测服务的，这点可以问我们的cdn厂商。</p>

<p>2.目前各端从jpg/png图片迁移肯定需要一段比较长的过程，并且需要cdn、后台等准备工作。</p>

<h1>参考：</h1>

<ol>
<li><p>WebP官方文档<a href="https://developers.google.com/speed/webp/">https://developers.google.com/speed/webp/</a></p></li>
<li><p>淘宝前端优化<a href="https://github.com/amfe/article/issues/21">https://github.com/amfe/article/issues/21</a></p></li>
<li><p>腾讯WebP探寻<a href="https://isux.tencent.com/introduction-of-webp.html">https://isux.tencent.com/introduction-of-webp.html</a></p></li>
<li><p>iOS WebP实践<a href="https://segmentfault.com/a/1190000006266276">https://segmentfault.com/a/1190000006266276</a></p></li>
<li><p>七牛云存储WebP支持<a href="https://segmentfault.com/a/1190000002726138">https://segmentfault.com/a/1190000002726138</a></p></li>
<li><p>探究WebP一些事儿<a href="http://web.jobbole.com/87103/">http://web.jobbole.com/87103/</a></p></li>
<li><p>Frequently Asked Questions<a href="https://developers.google.com/speed/webp/faq">https://developers.google.com/speed/webp/faq</a></p></li>
<li><p>七牛云图片处理<a href="http://blog.qiniu.com/archives/5793">http://blog.qiniu.com/archives/5793</a></p></li>
<li><p><a href="https://havecamerawilltravel.com/photographer/webp-website">https://havecamerawilltravel.com/photographer/webp-website</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android序列化方案比较]]></title>
    <link href="http://changety.github.io/blog/2014/10/19/android-serialization-compare/"/>
    <updated>2014-10-19T00:34:58+08:00</updated>
    <id>http://changety.github.io/blog/2014/10/19/android-serialization-compare</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>&emsp;&emsp;目前移动客户端应用程序上，需要将用户内容持久化到设备上，一般任何feed流应用，如微博、推特、新闻客户端等都需要将内容做持久化操作，以便在内存回收后，再次进入程序能迅速恢复之前的内容。另外如一些视频、音乐、购物等软件，凡是收藏的视频、歌曲、商品以及个人主页等，也应将这些用户私有的内容做序列化，以便无网进入时也能看到相关内容，并正常使用软件。陆陆续续使用和测试过一些Java序列化方案，这篇主要从Android客户端应用程序的角度，并以速度、序列化文件大小、实践简易性为主要考虑指标介绍并对比以下序列化方案。</p>

<hr />

<h1>JVM-Serializsers</h1>

<p>&emsp;&emsp;首先介绍一下<a href="https://github.com/eishay/jvm-serializers">JVM-Serializsers</a>，是一个很不错的测试序列化的工具，可以用它来评测各种流行的java序列化反序列化工具，在其测试模型上构建新的序列化使用上也很方便。本文结合JVM-Serializsers测试模型，并在其测试模型下新增测试了<a href="https://code.google.com/p/fast-serialization/">fast-serialization</a>的测试。本文重点介绍Java原生序列化、<a href="https://github.com/EsotericSoftware/kryo">Kryo</a>、<a href="https://code.google.com/p/fast-serialization/">fast-serialization</a>、<a href="http://code.alibabatech.com/wiki/display/FastJSON/Home">fastjson</a>、<a href="https://code.google.com/p/protobuf/">protocol-buffers</a>等几种典型的序列化方案。</p>

<hr />

<p><a href="https://github.com/eishay/jvm-serializers">JVM-Serializsers</a>下载源码后，具体步骤如下：</p>

<h4>1.切到jvm-seruakuzaers源码tcp目录下：</h4>

<p><img src="/images/android_serializaion/swich_term.png"></p>

<h4>2.编译源码：</h4>

<p><img src="/images/android_serializaion/make_compile.png"></p>

<h4>3.运行测试案案例：</h4>

<p><img src="/images/android_serializaion/test_serilization.png"></p>

<pre><code>./run -chart -include=kryo,fst-serialization,java-built-in,protobuf,hessian,json/google-gson/databind,
xml/xstream+c,bson/mongodb,bson/jackson/databind,json/fastjson/databind,json/jackson/databind,thrift,avro-generic data/media.1.cks
</code></pre>

<p>include参数代表要进行测试的序列化工具，当然前提是在jvm-serialization中的测试模型下已经构建完相应工具的测试用例。更多参数可通过./run -help看说明，如果带上-chart参数，还会生成序列化性能数据的图形对比。</p>

<hr />

<h3>测试环境：</h3>

<p>os：os x-10.9</p>

<p>jdk：java version &ldquo;1.7.0_51&rdquo;</p>

<p>mem：16G</p>

<p>cpu: 2.3 GHz Intel Core i7</p>

<hr />

<h3>运行结果：</h3>

<p><img src="/images/android_serializaion/test_serilization_result.png"></p>

<p>表中参数介绍：</p>

<p><code>Total Time (“total”)</code>：创建一个对象，将其序列化成一个字节数组，然后再反序列化成一个对象。</p>

<p><code>Serialization Time (“ser”)</code>：创建一个对象，将其序列化成一个字节数组。</p>

<p><code>Deserialization Time (“deser+deep”)</code>：相比于序列化，反序列化更耗时。为了更公平的比较，jvm-serializers在反序列化测试时访问了反序列化得到的对象的所有字段（也就是deep的含义），因为部分工具反序列化时“偷懒”而没有做足工作。</p>

<p><code>Serialized Size (“size”)</code>：序列化数据的大小，这个大小会依赖于使用的数据。</p>

<p><code>Serialization Compressed Size (“size+dfl”)</code>：使用java内置的DEFLATE(zlib)压缩的序列化数据的大小。</p>

<p><code>Object Creation Time (“create”)</code>：对象创建耗时很短（平均100纳秒）所以通常的比较没什么意义。不过，不同工具创建的对象在表现上会有不同。有的工具只是创建普通的java类，你可以直接访问其字段，而有的使用get/set方法，有的使用builder模式。</p>

<p>该工具还将这些数据通过google chart服务生成数据图形对比图：</p>

<p><img src="/images/android_serializaion/225646_yuk9_271796.png"></p>

<p>以上已经可以利用强大的JVM-Serializsers工具来分析跟构建自己想测试的序列化工具了，更多在Android Runtime的测试见下文。</p>

<hr />

<h1>Java序列化工具技术原理比较</h1>

<h2>Binary Formats &amp; language-specific ones：</h2>

<p>JavaBuiltIn（java原生）、JavaManual（根据成员变量类型，手工写）、<a href="https://code.google.com/p/fast-serialization/">FstSerliazation</a>、<a href="https://github.com/EsotericSoftware/kryo">Kryo</a></p>

<h2>Binary formats-generic language-unspecific ones：</h2>

<pre><code>[Protobuf](https://code.google.com/p/protobuf/)、[Thrift](https://thrift.apache.org/)、 [AvroGeneric](https://avro.apache.org/docs/current/)、[Hessian](http://hessian.caucho.com/)
</code></pre>

<h2>JSON Format：</h2>

<p><a href="http://jackson.codehaus.org/">Jackson</a>、<a href="https://code.google.com/p/google-gson/">Gson</a>、<a href="http://code.alibabatech.com/wiki/display/FastJSON/Home">FastJSON</a></p>

<h2>JSON-like：</h2>

<p>CKS  textual JSON-like format）、BSON（JSON-like format with extended datatypes）JacksonBson、<a href="http://docs.mongodb.org/meta-driver/latest/legacy/bson/">MongoDB</a></p>

<h2>XML-based formats：</h2>

<p><a href="http://xstream.codehaus.org/">XmlXStream</a></p>

<p>java的序列化工具大致就可以分为以上几类，简单概括就分为二进制binary和文本格式（json、xml）两大类。</p>

<p>从运行结果的图中可以较为明显的看出，在速度的对比上一般有如下规律：</p>

<pre><code>binary &gt; textual
language-specific &gt; language-unspecific
</code></pre>

<p>而textual中，由json相比xml冗余度更低因此速度上更胜一筹，而json又bson这类textual serialization技术上更成熟，框架的选择上更丰富和优秀。下面重点介绍下Kryo、fast-serialiation、fastjson、protocol-buffer</p>

<hr />

<h1>典型Java序列化工具分析</h1>

<h2>(1) Java原生序列化工具</h2>

<p>&emsp;&emsp;Java本身提供的序列化工具基本上能胜任大多数场景下的序列化任务，关于其序列化机制，<a href="http://blog.csdn.net/zhaozheng7758/article/details/7820018">这篇文章很细致的解释了</a>，值得一读。Java自带的序列化工具在序列化过程中需要不仅需要将对象的完整的class name记录下来，还需要把该类的定义也都记录下，包括所有其他引用的类，这会是一笔很大的开销，尤其是仅仅序列化单个对象的时候。正因为java序列化机制会把所有meta-data记录下来，因此当修改了类的所在的包名后，反序列化则会报错。Java自带序列化工具的性能问题总结如下：</p>

<ul>
<li><p>一个single object的序列化会递归地，连同所有成员变量（instsnce variables）一起序列化了，这种默认机制很容易造成不必要的序列化开销。</p></li>
<li><p>序列化和反序列化过程需要上面的这种机制去递归并用反射机制去寻找所有成员变量的信息，另外如果没定义自己serialVersionUID的话，那么对象及其他变量都必须自己产生一个。上述过程开销很大。</p></li>
<li><p>使用默认序列化机制，所有序列化类定义完整信息都会被记录下来，包括所有包名、父类信息、以及成员变量</p></li>
</ul>


<hr />

<h2>(2) 优化过的Java序列化工具</h2>

<p>&emsp;&emsp;<a href="https://github.com/EsotericSoftware/kryo">kryo</a></p>

<p>&emsp;&emsp;kryo根据上述Java原生序列化机制的一些问题，对了很多优化工作，而且提供了很多serializer，甚至封装了Unsafe类型的序列化方式，更多关于Unsafe类型的序列化方式，请参考这里，需要注意的是，jdk1.7以后，默认关闭unsafe的类（sun.misc.Unsafe）包。更多kryo介绍参考kryo的wiki，这里贴一下kryo的典型用法。其中CompatibeFieldSerializer就是默认提供的一系列serializer的一种，顾名思义就是一种成员变量上下兼容的序列化工具，支持该类对成员变量的增删。另外kryo更新比较活跃，问题修复很快。</p>

<pre><code class="java">private static Kryo myKryo = new Kryo();
static {
    myKryo.register(MusicInfo.class, new CompatibleFieldSerializer&lt;MusicInfo&gt;(myKryo, Media.class), 50);
}
public static void saveObjectByKryo(Object o, String fileName) {
    Output output = null;
    try {
        output = new Output(new FileOutputStream(fileName), 8 * 1024);
        myKryo.writeObject(output, o);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (output != null) {
         output.close();
        }
    }
}

public static Object readObjectByKryo(String filename, Class&lt;?&gt; clazz) {
    Input input = null;
    try {
        input = new Input(new FileInputStream(new File(filename)));
        return myKryo.readObject(input, clazz);
    } catch (Throwable t) {
        t.printStackTrace();
    } finally {
        if (input != null) {
            input.close();
        }
    }
    return null;
}
</code></pre>

<hr />

<p>&emsp;&emsp;<a href="https://code.google.com/p/fast-serialization/">fast-serialization</a></p>

<p>&emsp;&emsp;fast-serialozation相对来说是一个很新的序列化工具，虽然从2-1的评测上来看，速度于kryo有一些差距，但根据本人在生产环境上的场景上测试，效果几乎于kryo一致，都能瞬间反序列化出内容并渲染，该序列化的原理描述：</p>

<blockquote><ul>
<li><p>Fast Serialization reimplements Java Serialization with focus on speed, size and compatibility. This allows the use of FST with minimal code change.</p></li>
<li><p>FSTStructs implements a struct emulation to avoid de-/encoding completely. Use case is high performance message oriented software. Other applications are data exchange with other languages, reduction of FullGC by &lsquo;flattening&rsquo; complex Objects, fast offheap, Control of data locality (CPU cache friendly) for high performance computational tasks, allocation free java programs.</p></li>
</ul>
</blockquote>

<p>这里贴一下fast-serialization的使用方法，如果原来系统使用的Java原生的序列化工具，替换成fast-serialization非常简单：只要把Java的ObjectOutputStream与ObjectInputStream替换成FSTObjectOutput和FSTObjectInput就行了：</p>

<pre><code class="java">public static boolean saveObjectByJava(Object o, String filename) {
    FSTObjectOutput oos = null;
    ObjectOutputStream oos = null;
    try {
        oos = new FSTObjectOutput(new FileOutputStream(filename));
        oos.writeObject(o);
        oos.flush();
        return true;
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (oos != null) {
        try {
            oos.close();
            } catch (IOException e) {
            e.printStackTrace();
            }
        }
    }
    return false;
}
public static Object readObjectByJava(String filename) {
    FSTObjectInput ois = null;
    ObjectInputStream ois = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(filename));
        return ois.readObject();
    } catch (Throwable t) {
        t.printStackTrace();
    } finally {
        if (ois != null) {
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return null;
}
</code></pre>

<hr />

<h2>（3）JSON</h2>

<p>&emsp;&emsp;从上一节的多种序列化工作的表现来看，比较优秀的JSON解析工具的表现还是比较好的，有些json解析工具甚至速度超过了一些二进制的序列化方式。Android环境下也有评测json解析性能的<a href="https://github.com/martinadamek/json-android-compare/wiki">demo</a>，下图可以看出jackson在速度上还是比较有优势的，但与Android自带的json包，也没有数量级以上的优势，而jackson的jar包大小达1mb多，因此对于普通的android应用来说是比较奢侈的。</p>

<p><img src="/images/android_serializaion/230423_zCZn_271796.png"></p>

<h2>4）Protocol-Buffer</h2>

<p>&emsp;&emsp;Protocol buffers是一个用来序列化结构化数据的技术，支持多种语言诸如C++、Java以及Python语言，可以使用该技术来持久化数据或者序列化成网络传输的数据。相比较一些其他的XML技术而言，该技术的一个明显特点就是更加节省空间（以二进制流存储）、速度更快以及更加灵活。 通常，编写一个protocol buffers应用需要经历如下三步：</p>

<p>1、定义消息格式文件，最好以proto作为后缀名</p>

<p>2、使用Google提供的protocol buffers编译器来生成代码文件，一般为.h和.cc文件，主要是对消息格式以特定的语言方式描述</p>

<p>3、使用protocol buffers库提供的API来编写应用程序</p>

<p>具体方法可参考google Protobuf 提供的详细的<a href="https://developers.google.com/protocol-buffers/docs/overview">developer guide</a></p>

<hr />

<h1>总结</h1>

<ul>
<li><p>就已有原先使用Java原生序列化方案的系统来说，kryo于fst-serializer是良好的java原生序列化方案替代者，不仅体现再编程简单，而且速度与性能上会有大幅提升，尤其是fst-serializer ，只需替代output/inputstream 即可，性能的提升上也很可观，目前该工具刚出来，稳定性还需要多测测。</p></li>
<li><p>如果程序本身就用json格式序列化，则可以考虑引入一个性能优异的json解析库，一般再服务端jackson是广受欢迎的解析库，但是其1.1mb的jar包大小对一般的Android应用有点奢侈，而fastjson在Android上的表现似乎没有再JDK上那么好，不过也比大多数解析库快了。另外用textual格式序列化对象，在Android客户端上还要考虑一些安全问题。</p></li>
<li><p>protobuffer更多的是一种取代xml的夸语言的消息交换格式，尽快速度很快，但是编程上需要定义消息格式，对成员变量多、业务复杂的javabean来说代价是较为复杂的，对稳定的已有系统来说总体代价较高。</p></li>
</ul>


<p>下表是几种方案的各项指标的一个对比 ：</p>

<table>
<thead>
<tr>
<th>序列化工具      </th>
<th> 序列化速度 </th>
<th> 序列化文件大小 </th>
<th> 编程模型复杂度  </th>
<th> 社区活跃度  </th>
<th> jar包大小 </th>
</tr>
</thead>
<tbody>
<tr>
<td>kryo           </td>
<td> 极快      </td>
<td> 小            </td>
<td> 简单          </td>
<td>     高       </td>
<td> 132kb  </td>
</tr>
<tr>
<td>fst-serializer </td>
<td> 快        </td>
<td> 小            </td>
<td> 非常简单      </td>
<td>     高       </td>
<td> 246kb  </td>
</tr>
<tr>
<td>protobuffer    </td>
<td> 快        </td>
<td> 较大          </td>
<td> 复杂          </td>
<td>     稳定      </td>
<td> 329kb  </td>
</tr>
<tr>
<td>fastjson       </td>
<td> 较快      </td>
<td> 较大          </td>
<td> 简单          </td>
<td>     稳定       </td>
<td> 338kb  </td>
</tr>
<tr>
<td>jackson        </td>
<td> 一般      </td>
<td> 较大          </td>
<td> 简单          </td>
<td>     稳定       </td>
<td> 1.1mb  </td>
</tr>
<tr>
<td>gson           </td>
<td> 较慢      </td>
<td> 较大          </td>
<td> 简单          </td>
<td>     稳定       </td>
<td> 189kb  </td>
</tr>
</tbody>
</table>


<hr />

<h1>参考资料</h1>

<p>Java序列化机制介绍及简单优化方法： <a href="http://www.javacodegeeks.com/2010/07/java-best-practices-high-performance.html">http://www.javacodegeeks.com/2010/07/java-best-practices-high-performance.html</a></p>

<p>Java序列化“最佳”实践： <a href="http://www.javacodegeeks.com/2010/07/java-best-practices-high-performance.html">http://www.javacodegeeks.com/2010/07/java-best-practices-high-performance.html</a></p>

<p>提升Java序列化的几种方法： <a href="http://www.javacodegeeks.com/2013/09/speed-up-with-fast-java-and-file-serialization.html">http://www.javacodegeeks.com/2013/09/speed-up-with-fast-java-and-file-serialization.html</a></p>

<p>详细的Java序列化过程： <a href="http://blog.csdn.net/zhaozheng7758/article/details/7820018">http://blog.csdn.net/zhaozheng7758/article/details/7820018</a></p>

<p>Unsafe类型的Java序列化方法： <a href="http://www.javacodegeeks.com/2012/07/native-cc-like-performance-for-java.html">http://www.javacodegeeks.com/2012/07/native-cc-like-performance-for-java.html</a></p>

<p>protobuf介绍1：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/">http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/</a></p>

<p>protobuf介绍2： <a href="http://www.cnblogs.com/royenhome/archive/2010/10/29/1864860.html">http://www.cnblogs.com/royenhome/archive/2010/10/29/1864860.html</a></p>
]]></content>
  </entry>
  
</feed>
